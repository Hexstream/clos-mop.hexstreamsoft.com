<p><strong>This file is meant to be consulted at the source level only.</strong></p>

<!-- You only need to check the HTML comments, the rest is just surrounding context. -->


http://metamodular.com/CLOS-MOP/add-method.html
Page 168

<li>
  <p>add <var>method</var> to the set returned by <a href="#generic-function-methods" class="body-link generic-function audited">generic-function-methods</a> and <!-- Robert Strandh version is missing previous "and". --> arrange for <a href="#method-generic-function" class="body-link generic-function audited">method-generic-function</a> to return <var>generic-function</var>;</p>
</li>




http://metamodular.com/CLOS-MOP/class-precedence-list.html
Page 214

<p>During class finalization <a href="#finalize-inheritance" class="body-link generic-function audited">finalize-inheritance</a> calls <a href="#compute-class-precedence-list" class="body-link generic-function audited">compute-class-precedence-list</a> to compute the class precedence list of the class. That value is associated with the class metaobject and is returned by <span class="name self generic-function">class-precedence-list</span>.</p>
<!-- Above, Robert Strandh version has duplicate "calls". -->



http://metamodular.com/CLOS-MOP/class-prototype.html
Page 214

<!-- The following paragraph is missing from Robert Strandh version. -->
<p>This generic function signals an error if <var>class</var> has not been finalized.</p>



http://metamodular.com/CLOS-MOP/compute-applicable-methods-using-classes.html
Page 171

<h1><span class="type">Generic Function</span> <span class="name self">compute-applicable-methods-using-classes</span></h1>

<p class="args-and-retvals"><var>generic-function</var> <var>classes</var> =&gt; <var>methods</var><!-- Robert Strandh version had comma here, but that seems superfluous. --> <var>ok</var></p>



http://metamodular.com/CLOS-MOP/compute-applicable-methods-using-classes-standard-generic-function.html
Page 172

<p>This method can be overridden. Because of the consistency requirements between this generic function and <a href="#compute-applicable-methods" class="body-link generic-function audited">compute-applicable-methods</a>,<!-- Robert Strandh version omits the preceding comma. --> doing so may require also overriding <a href="#compute-applicable-methods_standard-generic-function" class="body-link method audited">compute-applicable-methods (standard-generic-function t)</a>.</p>



http://metamodular.com/CLOS-MOP/compute-class-precedence-list.html
Page 173

<!-- The following paragraph is missing from the Robert Strandh version. -->
<p>The list returned by this generic function will not be mutated by the implementation. The results are undefined if a portable program mutates the list returned by this generic function.</p>



http://metamodular.com/CLOS-MOP/compute-default-initargs-standard-class.html
http://metamodular.com/CLOS-MOP/compute-default-initargs-funcallable-standard-class.html
Page 174

<!-- Robert Strandh version split this definition into two almost exact duplicates instead. -->

<section class="description">
  <h1>Description</h1>
  <p>These methods compute the default initialization arguments according to the rules described in the section of the CLOS Specification called <q><a href="http://www.cs.cmu.edu/Groups/AI/html/cltl/clm/node295.html#SECTION003219300000000000000" class="body-link cltl2 audited">Defaulting of Initialization Arguments</a></q>.</p>
  <div class="page">
    <a href="../raw/pages/175.png" target="_blank">[Page 175]</a>
  </div>
  <p>These methods signal an error if <var>class</var> or any of its superclasses is a forward referenced class.</p>
  <p>These methods can be overridden.</p>
</section>

<section class="comments-and-remarks">
  <!-- Somehow called "Issues" in Robert Strandh version. -->
  <h1>Comments and remarks</h1>
  <p>How can <var>class</var> be a forward referenced class?</p>
</section>



http://metamodular.com/CLOS-MOP/compute-discriminating-function.html
Page 176

<p>Determination of the effective method is done by calling <a href="#compute-effective-method" class="body-link generic-function audited">compute-effective-method</a>.<!-- Robert Strandh version is missing the preceding dot. --> When the effective method is run, each method's function is called, and receives as arguments: (i) a list of the arguments to the generic function, and (ii) whatever other arguments are specified in the <a href="file:///home/hexstream/quicklisp/HyperSpec/Body/m_call_m.htm" class="body-link clhs audited">call-method</a> form indicating that the method should be called. (See <a href="#make-method-lambda" class="body-link generic-function audited">make-method-lambda</a> for more information about how method functions are called.)</p>

[...]

<h1>Comments and remarks</h1>
<!-- Robert Strandh version said "Remarks", but I'm pretty sure that was intended as a "Comments and remarks". -->




http://metamodular.com/CLOS-MOP/compute-slots.html
Page 179

<li><var>effective-slot-definitions</var> -- A set of effective slot definition metaobjects.</li>
<!-- Robert Strandh version (not incorrectly?) says "list" instead of "set". -->

[...]

<!-- The following paragraph is missing from the Robert Strandh version. -->
<p>The list returned by this generic function will not be mutated by the implementation. The results are undefined if a portable program mutates the list returned by this generic function.</p>



http://metamodular.com/CLOS-MOP/compute-slots-around-standard-class.html
http://metamodular.com/CLOS-MOP/compute-slots-around-funcallable-standard-class.html
Page 180

<p>This method cannot be overridden.</p>
<!-- Robert Strandh version uses (the equivalent of) "can <strong>not</strong>" instead of "cannot". (Which is arguably better, but in general I'm being more faithful to the book.) -->



http://metamodular.com/CLOS-MOP/direct-slot-definition-class.html
Page 180

<section class="arguments-and-values">
  <h1>Arguments and Values</h1>
  <ul>
    <li><var>class</var> -- A class metaobject.</li>
    <li><var>initargs</var> -- A list of initialization arguments and values.</li>
    <li><var>slot-definition-class</var> -- A class metaobject which is a subclass of the class <a href="../classes/#direct-slot-definition" class="body-link class fixme">direct-slot-definition</a>.</li>
  </ul>
</section>

[...]

<section class="values">
  <h1>Values</h1>
  <p>The value returned is a subclass of the class <a href="../classes/#direct-slot-definition" class="body-link class fixme">direct-slot-definition</a>.</p>
  <!-- Robert Strandh version puts the above paragraph in the description, I'm putting it in the Arguments and Values section instead. -->
</section>

<!-- In case this is confusing, my version will support both the "Arguments and Values" bullet points style (as in your version and CLHS) and separate "Arguments" and "Values" prose (as in the book), configurable through preferences. The "Arguments and Values" style will be the default. I added support for separate "Arguments" and "Values" mostly to make it easier to audit my version using the book. -->



http://metamodular.com/CLOS-MOP/ensure-class.html
Page 182

<!-- The rest of this section is missing from the Robert Strandh version. -->
<p>The first argument to <a href="#ensure-class-using-class" class="body-link generic-function audited">ensure-class-using-class</a> is computed as follows:</p>
<ul>
  <li>
    <p>If <var>name</var> names a class (<a href="file:///home/hexstream/quicklisp/HyperSpec/Body/f_find_c.htm" class="body-link clhs audited">find-class</a> returns a class when called with <var>name</var>) use that class.</p>
  </li>
  <li>
    <p>Otherwise use <a href="http://www.lispworks.com/documentation/HyperSpec/Body/v_nil.htm" class="body-link clhs constant nil audited">nil</a>.</p>
  </li>
</ul>
<p>The second argument is <var>name</var>. The remaining arguments are the complete set of keyword arguments received by the <span class="name self function">ensure-class</span> function.</p>



http://metamodular.com/CLOS-MOP/ensure-class-using-class-forward-referenced-class.html
Page 185

<p>This method implements the behavior of the generic function in the case where the <var>class</var> argument is a forward referenced class.</p>
<!-- Above, Robert Strandh version said "reference" instead. -->



http://metamodular.com/CLOS-MOP/eql-specializer-object.html
Page 188

<li><var>eql-specializer</var> -- An <code>eql</code> specializer metaobject.</li>
<!-- Above, Robert Strandh version said "object" instead of "metaobject". -->



http://metamodular.com/CLOS-MOP/funcallable-standard-instance-access.html
Page 192

<li>
  <p>The <var>instance</var> argument must be a funcallable instance (it must have been returned by <a href="#allocate-instance_funcallable-standard-class" class="body-link method audited">allocate-instance (<var>class</var> funcallable-standard-class)</a>).</p>
</li>
<!-- Above, the last closing parenthesis is missing in the Robert Strandh version. -->



http://metamodular.com/CLOS-MOP/readers-for-generic-function-metaobjects.html
Page 216

<!-- First correction below uses text from Robert Strandh version. (Except I'm using "return" instead of "returns".) I'm using my own text for the second correction.-->

<p><span class="amop-typo" data-original="The list returned by this generic function">For any of these generic functions which return a list, such lists</span> will not be mutated by the implementation. The results are undefined if a portable program mutates <span class="amop-typo" data-original="the list returned by this generic function">such a list</span>.</p>



http://metamodular.com/CLOS-MOP/generic-function-methods.html
Page 217

<h1><span class="type">Generic Function</span> <span class="name self">generic-function-methods</span></h1>

<p class="args-and-retvals"><var>generic-function</var> =&gt; <var>list</var></p>

<!-- Above, Robert Strandh version incorrectly used "symbols" as return value. -->



http://metamodular.com/CLOS-MOP/initialization-of-class-metaobjects2.html
Page 196

<ul>
  <li>
    <p>Portable programs must not define methods on <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm#shared-initialize" class="body-link clhs audited">shared-initialize</a>.</p>
  </li>
  <li>
    <p>For <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance" class="body-link clhs audited">initialize-instance</a> and <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance" class="body-link clhs audited">reinitialize-instance</a>:</p>
    <ul>
      <li>
        <p>Portable programs must not define primary methods.</p>
      </li>
      <li><p>Portable programs may define around-methods, but these must be extending, not overriding methods.</p></li>
      <li>
        <p>Portable before-methods must assume that when they are run, none of the initialization behavior described above has been completed.</p>
      </li>
      <li>
        <p>Portable after-methods must assume that when they are run, all of the initialization behavior described above has been completed.</p>
      </li>
    </ul>
  </li> <!-- Robert Strandh version forgot this </li>.-->
</ul>



http://metamodular.com/CLOS-MOP/initialization-of-generic-function-metaobjects.html
Page 198

<li>
  <p>
    The <var class="keyword-initarg">:argument-precedence-order</var> argument is a list of symbols.
  </p>
  <p>An error is signaled if this argument appears but the <var class="keyword-initarg">:lambda-list</var> argument does not appear. An error is signaled if this value is not a proper list or if this value is not a permutation of the symbols from the required arguments part of the <var class="keyword-initarg">:lambda-list</var> initialization argument.</p>
  <p>When the generic function is being initialized or reinitialized, and this argument is not supplied, but the <var class="keyword-initarg">:lambda-list</var> argument is supplied, this value defaults to the symbols from the required arguments part of the <var class="keyword-initarg">:lambda-list</var> argument, in the order they appear in that argument. If neither argument is supplied, neither are initialized (see the description of <var class="keyword-initarg">:lambda-list</var><span class="amop-typo" data-original=".)">).</span></p>
</li> <!-- Robert Strandh version forgot this </li> -->

[...]

<li>
  <p>The <var class="keyword-initarg">:method-combination</var> argument is a method combination metaobject.</p>
</li> <!-- Robert Strandh version forgot to wrap this in a <p></p>. -->




http://metamodular.com/CLOS-MOP/initialization-of-generic-function-metaobjects.html
Page 199

<!-- Below, Robert Strandh version doesn't use <p>s, probably because each <li> has one paragraph. -->

<ul>

  <li>
    <p>Portable programs must not define methods on <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm#shared-initialize" class="body-link clhs audited">shared-initialize</a>.</p>
  </li>

  <li>

    <p>For <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance" class="body-link clhs audited">initialize-instance</a> and <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance" class="body-link clhs audited">reinitialize-instance</a>:</p>
    <ul>

      <li>
        <p>Portable programs must not define primary methods.</p>
      </li>

      <li>
        <p>Portable programs may define around-methods, but these must be extending, not overriding methods.</p>
      </li>

      <li>
        <p>Portable before-methods must assume that when they are run, none of the initialization behavior described above has been completed.</p>
      </li>

      <li>
        <p>Portable after-methods must assume that when they are run, all of the initialization behavior described above has been completed.</p>
      </li>

    </ul>

  </li>

</ul>




http://metamodular.com/CLOS-MOP/initialization-of-method-metaobjects.html
Page 200

<p>In these descriptions, the phrase <q>this argument defaults to <I>value</I></q> means that when that initialization argument is not supplied, initialization <!-- FIXME: Robert Strandh version says "or reinitialization", the book does not, which is right? --> is performed as if <I>value</I> had been supplied. For some initialization arguments this could be done by the use of default initialization arguments, but whether it is done this way is not specified. Implementations are free to define default initialization arguments for specified method metaobject classes. Portable programs are free to define default initialization arguments for portable subclasses of the class <a href="http://www.lispworks.com/documentation/HyperSpec/Body/t_method.htm#method" class="body-link clhs audited">method</a>.</p>



http://metamodular.com/CLOS-MOP/initialization-of-method-metaobjects.html
Page 202

<p>These restrictions govern the methods that a portable program can define on the generic functions <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance" class="body-link clhs audited">initialize-instance</a>,<!-- Previous comma is missing in Robert Strandh version. --> <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance" class="body-link clhs audited">reinitialize-instance</a>, and <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm#shared-initialize" class="body-link clhs audited">shared-initialize</a>. These restrictions apply only to methods on these generic functions for which the first specializer is a subclass of the class <a href="http://www.lispworks.com/documentation/HyperSpec/Body/t_method.htm#method" class="body-link clhs audited">method</a>. Other portable methods on these generic functions are not affected by these restrictions.</p>

<ul>

  <li>
    <p>Portable programs must not define methods on <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm#shared-initialize" class="body-link clhs audited">shared-initialize</a> or <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_reinit.htm#reinitialize-instance" class="body-link clhs audited">reinitialize-instance</a>.</p>
  </li>

  <li>
    <p>For <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance" class="body-link clhs audited">initialize-instance</a>:</p>
    <ul>
      <li>
        <p>Portable programs must not define primary methods.</p>
      </li>

      <li>
        <p>Portable programs may define around-methods, but these must be extending, not overriding methods.</p>
      </li>

      <li>
        <p>Portable before-methods must assume that when they are run, none of the initialization behavior described above has been completed.</p>
      </li>

      <li>
        <p>Portable after-methods must assume that when they are run, all of the initialization behavior described above has been completed.</p>
      </li>
    </ul>
  </li> <!-- Robert Strandh version forgot this </li> -->
</ul>



http://metamodular.com/CLOS-MOP/initialization-of-slot-definition-metaobjects.html
Page 203

<!-- Many weird markup troubles below in Robert Strandh version. -->

<!-- I don't really want to reverse-engineer what the problems were again, use https://validator.w3.org/ to find the problems. -->



http://metamodular.com/CLOS-MOP/initialization-of-slot-definition-metaobjects.html
Page 205

<p>These restrictions govern the methods that a portable program can define on the generic functions <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_init_i.htm#initialize-instance" class="body-link clhs audited">initialize-instance</a>, <a href="file:///home/hexstream/quicklisp/HyperSpec/Body/f_reinit.htm" class="body-link clhs audited">reinitialize-instance</a>, and <a href="http://www.lispworks.com/documentation/HyperSpec/Body/f_shared.htm" class="body-link audited">shared-initialize</a>. These restrictions apply only to methods on these generic functions for which the first specializer is a subclass of the class <a href="../classes/#slot-definition" class="body-link class fixme">slot-definition</a>. Other portable methods on these generic functions are not affected by these restrictions.</p>

<!-- Robert Strandh version duplicates the above paragraph. -->



http://metamodular.com/CLOS-MOP/intern-eql-specializer.html
Page 206

<section class="arguments-and-values">
  <h1>Arguments and Values</h1>
  <ul>
    <li><var>object</var> -- Any Lisp object.</li>
    <li><var>eql-specializer</var> -- The <code>eql</code> specializer metaobject for <var>object</var>.</li>
  </ul>
  <!-- Robert Strandh version simply said "An object." and "An eql specializer.", which is not a bad idea. -->
</section>



http://metamodular.com/CLOS-MOP/readers-for-method-metaobjects.html
Page 220

<p>The specified methods for the method metaobject readers are presented below.</p>

<!-- Above, Robert Strandh version says "reader generic functions", instead of "readers" as in the book. Maybe that's a good idea, I don't know. In case of doubt, I'm faithful to the book. -->



http://metamodular.com/CLOS-MOP/reader-method-class.html
Page 224

<li><var>initargs</var> -- Alternating initialization argument names and values.</li>
<!-- Above, Robert Strandh's version says "A suite of [...]", which is very odd. -->



http://metamodular.com/CLOS-MOP/setf-slot-value-using-class.html
Page 232

<ul>
  <li><a href="#setf_slot-value-using-class_t_standard-class_t_standard-effective-slot-definition" class="body-link method audited"><span class="name">(setf slot-value-using-class)</span> <var>new-value</var> (<var>class</var> standard-class) <var>object</var> (<var>slot</var> standard-effective-slot-definition)</a></li>
  <li><a href="#setf_slot-value-using-class_t_funcallable-standard-class_t_standard-effective-slot-definition" class="body-link method audited"><span class="name">(setf slot-value-using-class)</span> <var>new-value</var> (<var>class</var> funcallable-standard-class) <var>object</var> (<var>slot</var> standard-effective-slot-definition)</a></li>
  <li><a href="#setf_slot-value-using-class_t_built-in-class" class="body-link method audited"><span class="name">(setf slot-value-using-class)</span> <var>new-value</var> (<var>class</var> built-in-class) <var>object</var> <var>slot</var></a></li>
</ul>
<!-- Robert Strandh version forgot <var>object</var> on method links. -->
<!-- Also, last method link incorrectly specialized on standard-effective-slot-definition. -->



http://metamodular.com/CLOS-MOP/slot-boundp-using-class.html
Page 234

<section class="remarks">
  <h1>Remarks</h1>
  <p>In cases where the class metaobject class does not distinguish unbound slots, true should be returned.</p>
</section>

<!-- Robert Strandh version incorrectly designates the above as a "Comments and remarks". This one is part of the book. -->



http://metamodular.com/CLOS-MOP/slot-definition-type.html
Page 222

<p>Returns the <span class="amop-typo" data-original="allocation">type</span> of <var>slot</var>. This is a type specifier name. This is the defaulted value of the <var class="keyword-initarg"><span class="amop-typo" data-original=":name">:type</span></var> initialization argument that was associated with the slot definition metaobject during initialization.</p>
<!-- Robert Strandh version has a TeX residue in paragraph above.-->



http://metamodular.com/CLOS-MOP/slot-makunbound-using-class.html
Page 235

<!-- Robert Strandh version has an incorrectly copy/pasted remarks (mislabeled as comments-and-remarks) block here. -->



http://metamodular.com/CLOS-MOP/specializer-direct-generic-functions-eql-specializer.html
Page 237

<h1><span class="type">Method</span> <span class="name self">specializer-direct-generic-functions</span></h1>

<p class="args-and-retvals">(<var>specializer</var> eql-specializer) =&gt; <var>generic-functions</var></p>

<!-- Robert Strandh version typo above: "eql-specilizer". -->



http://metamodular.com/CLOS-MOP/specializer-direct-methods-eql-specializer.html
Page 238


<h1><span class="type">Method</span> <span class="name self">specializer-direct-methods</span></h1>

<p class="args-and-retvals">(<var>specializer</var> eql-specializer) =&gt; <var>methods</var></p>

<!-- Robert Strandh version typo above: "eql-specilizer". -->




http://metamodular.com/CLOS-MOP/update-dependent.html
Page 240

<section class="remarks">
  <h1>Remarks</h1>
  <p>See the <q><a href="../concepts/#dependent-maintenance-protocol" class="body-link chapter5 audited">Dependent Maintenance Protocol</a></q> section for remarks about the use of this facility.</p>
</section>

<!-- Robert Strandh version said "Comments and remarks" but this is just a plain "Remarks". -->



http://metamodular.com/CLOS-MOP/validate-superclass.html
Page 241

<section class="remarks">
  <h1>Remarks</h1>
  <p>Defining a method on <span class="name self generic-function">validate-superclass</span> requires detailed knowledge of <span class="amop-typo" data-original="of"></span> the internal protocol followed by each of the two class metaobject classes. A method on <span class="name self generic-function">validate-superclass</span> which returns true for two different class metaobject classes declares that they are compatible.</p>
</section>

<!-- Robert Strandh version said "Comments and remarks" but this is just a plain "Remarks". -->



http://metamodular.com/CLOS-MOP/writer-method-class.html
Page 242

<li><var>initargs</var> -- A list of initialization arguments and values.</li>
<!-- Above, why does Robert Strandh version say "suite"?? -->
