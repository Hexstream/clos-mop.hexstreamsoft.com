<strong>This file is meant to be consulted at the source level only.</strong>

<!-- You only need to check the HTML comments, the rest is just surrounding context. -->



http://metamodular.com/CLOS-MOP/implementation-and-user-specialization.html
Page 142

<!-- Robert Strandh had separated this into 2 subpoints but I'm being more faithful to the book. -->
<li>
  <p>A method is <i>specialized to</i> <!-- Robert Strandh used "for" instead of "to", not sure if that was intentional. Also, he italicized only "specialized", not also the following word. Easy to miss, but the "to" seems to also be italicized. --> a class if and only if that class is in the list of specializers associated with the method; and the method is in the list of methods associated with some generic function.</p>
</li>

<li>
  <p>In a given implementation, a specified method is said to have been <i>promoted</i> if and only if the specializers of the method, <var>S<sub>1</sub></var> ... <var>S<sub>n</sub></var><!-- Robert Strandh omitted the following comma, not sure if intentional. -->, are defined in this specification as the classes <var>C<sub>1</sub></var> ... <var>C<sub>n</sub></var>, but in the implementation, one or more of the specializers <var>S<sub>i</sub></var>, is a superclass of the class given in the specification <var>C<sub>i</sub></var>.</p>
</li>


http://metamodular.com/CLOS-MOP/implementation-and-user-specialization.html
Page 143

<!-- Not sure why the 3 "call-next-method" here are merely bolded instead of linked in the Robert Strandh version. -->



http://metamodular.com/CLOS-MOP/restrictions-on-portable-programs.html
Page 144

<p>An example of this is the specified methods on the generic functions <a href="../generic-functions-and-methods/#add-dependent" class="body-link generic-function audited">add-dependent</a>, <a href="../generic-functions-and-methods/#remove-dependent" class="body-link generic-function audited">remove-dependent</a><!-- Robert Strandh version had Oxford comma here, not sure if intentional. --> and <a href="../generic-functions-and-methods/#map-dependents" class="body-link generic-function audited">map-dependents</a>. Overriding a specified method on one of these generic functions requires that the corresponding method on the other two generic functions be overridden as well.</p>


http://metamodular.com/CLOS-MOP/the-defclass-macro.html
Page 146

<li>
  <p>The <var>direct-superclasses</var> argument to <a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defcla.htm#defclass" class="body-link clhs audited">defclass</a> becomes the value of the <code>:direct-superclasses</code><!-- Robert Strandh version mistakenly said ":direct-super-classes" --> keyword argument to <a href="../generic-functions-and-methods/#ensure-class" class="body-link function audited">ensure-class</a>.</p>
</li>



http://metamodular.com/CLOS-MOP/the-defclass-macro.html
Page 147

(Quite a lot of surrounding context here, but basically there are two nesting errors. As always, you just need to check the HTML comments.)


<li>
  <p>The <var class="amop-typo" data-original="direct slots">direct-slots</var> argument to <a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defcla.htm#defclass" class="body-link clhs audited">defclass</a> becomes the value of the <code>:direct-slots</code> keyword argument to <a href="../generic-functions-and-methods/#ensure-class" class="body-link function audited">ensure-class</a>. Special processing of this value is done to regularize the form of each slot specification and to properly capture the lexical scope of the initialization forms. This is done by converting each slot specification to a property list called a <i>canonicalized slot specification</i>. The resulting list of canonicalized slot specifications is the value of the <code>:direct-slots</code> keyword argument.</p>
  <div class="page">
    <a href="../raw/pages/147.png" target="_blank">[Page 147]</a>
  </div>
  <p>Canonicalized slot specifications are later used as the keyword arguments to a generic function which will, in turn, pass them to <a href="../generic-functions-and-methods/#make-instance" class="body-link generic-function audited">make-instance</a> for use as a set of initialization arguments. Each canonicalized slot specification is formed from the corresponding slot specification as follows:</p>
  <!-- Robert Strandh version prematurely ended the current <li>, such that the following <ul> is not properly nested inside it, instead an implicit <li> is being created for the following <ul> (since <ul> can only contain <li>s), which is why the nested list still appears to be at the correct nesting level. -->
  <ul>
    <li>
      <p>The name of the slot is the value of the <code>:name</code> property. This property appears in every canonicalized slot specification.</p>
    </li>
    <li>
      <p>When the <code>:initform</code> slot option is present in the slot specification, then both the <code>:initform</code> and <code>:initfunction</code> properties are present in the canonicalized slot specification. The value of the <code>:initform</code> property is the initialization form. The value of the <code>:initfunction</code> property is a function of zero arguments which, when called, returns the result of evaluating the initialization form in its proper lexical environment.</p>
      <p>If the <code>:initform</code> slot option is not present in the slot specification, then either the <code>:initfunction</code> property will not appear, or its value will be false. In such cases, the value of the <code>:initform</code> property, or whether it appears, is unspecified.</p>
    </li>
    <li>
      <p>The value of the <code>:initargs</code> property is a list of the values of each <code>:initarg</code> slot option. If there are no <code>:initarg</code> slot options, then either the <code>:initargs</code> property will not appear or its value will be the empty list.</p>
    </li>
    <li>
      <div class="page">
        <a href="../raw/pages/148.png" target="_blank">[Page 148]</a>
      </div>
      <p>The value of the <code>:readers</code> property is a list of the values of each <code>:reader</code> and <code>:accessor</code> slot option. If there are no <code>:reader</code> or <code>:accessor</code> slot options, then either the <code>:readers</code> property will not appear or its value will be the empty list.</p>
    </li>
    <li>
      <p>The value of the <code>:writers</code> property is a list of the values specified by each <code>:writer</code> and <code>:accessor</code> slot option. The value specified by a <code>:writer</code> slot option is just the value of the slot option. The value specified by an <code>:accessor</code> slot option is a two element list: the first element is the symbol <code>setf</code>, the second element is the value of the slot option. If there are no <code>:writer</code> or <code>:accessor</code> slot options, then either the <code>:writers</code> property will not appear or its value will be the empty list.</p>
    </li>
    <li>
      <p>The value of the <code>:documentation</code> property is the value of the <code>:documentation</code> slot option. If there is no <code>:documentation</code> slot option, then either the <code>:documentation</code> property will not appear or its value will be false.</p>
    </li>
    <li>
      <p>All other slot options appear as the values of properties with the same name as the slot option. Note that this includes not only the remaining standard slot options (<code>:allocation</code> and <code>:type</code>), but also any other options and values appearing in the <span class="page-transition"></span> slot specification. If one of these slot options appears more than once, the value of the property will be a list of the specified values.</p>
    </li>
    <li>
      <div class="page approximate">
        <a href="../raw/pages/149.png" target="_blank">â†³[Page 149]</a>
      </div>
      <p>An implementation is free to add additional properties to the canonicalized slot specification provided these are not symbols accessible in the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/11_abb.htm" class="body-link clhs audited">common-lisp-user</a> package, or exported by any package defined in the ANSI Common Lisp standard.</p>
    </li>
  </ul>
</li>
</ul>

<!-- Robert Strandh version incorrectly nested <p> directly inside <ul>. -->
<p>Returning to the correspondence between arguments to the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defcla.htm#defclass" class="body-link clhs audited">defclass</a> macro and the arguments received by the <a href="../generic-functions-and-methods/#ensure-class" class="body-link function audited">ensure-class</a> function:</p>

<ul>
  <li>
    <p>The <var class="amop-typo" data-original="default initargs">default-initargs</var> class option, if it is present in the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defcla.htm#defclass" class="body-link clhs audited">defclass</a> form, becomes the value of the <code>:direct-default-initargs</code> keyword argument to <a href="../generic-functions-and-methods/#ensure-class" class="body-link function audited">ensure-class</a>. Special processing of this value is done to properly capture the lexical scope of the default value forms. This is done by converting each default initarg in the class option into a <i>canonicalized default initarg</i>. The resulting list of canonicalized default initargs is the value of the <code>:direct-default-initargs</code> keyword argument to <a href="../generic-functions-and-methods/#ensure-class" class="body-link function audited">ensure-class</a>.</p>
    <p>A canonicalized default initarg is a list of three elements. The first element is the name; the second is the actual form itself; and the third is a function of zero arguments which, when called, returns the result of evaluating the default value form in its proper lexical environment.</p>
  </li>

  <li>
    <p>The <var>metaclass</var> class option, if it is present in the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defcla.htm#defclass" class="body-link clhs audited">defclass</a> form, becomes the value of the <code>:metaclass</code> keyword argument to <a href="../generic-functions-and-methods/#ensure-class" class="body-link function audited">ensure-class</a>.</p>
  </li>

  <li>
    <p>The <var>documentation</var> class option, if it is present in the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defcla.htm#defclass" class="body-link clhs audited">defclass</a> form, becomes the value of the <code>:documentation</code> keyword argument to <a href="../generic-functions-and-methods/#ensure-class" class="body-link function audited">ensure-class</a>.</p>
  </li>

  <li>
    <p>Any other class options become the value of keyword arguments with the same name. The value of the keyword argument is the tail of the class option. An error is signaled if any class option appears more than once in the <a href="http://www.lispworks.com/documentation/HyperSpec/Body/m_defcla.htm#defclass" class="body-link clhs audited">defclass</a> form.</p>
  </li>

</ul>





http://metamodular.com/CLOS-MOP/the-defmethod-macro.html
Page 150

<p>The initialization arguments received by the call to <a href="../generic-functions-and-methods/#make-instance" class="body-link generic-function audited">make-instance</a> are as follows:</p>

<!-- ":qualifiers" and such are somehow missing the colon in Robert Strandh version. -->



http://metamodular.com/CLOS-MOP/fig-defmethod-1.html
Page 151

<!-- Robert Strandh version had \em and \tt TeX leftovers above. -->



http://metamodular.com/CLOS-MOP/fig-defmethod-2.html
Page 152

<!-- In Robert Strandh version, "environment" above is slightly incorrectly indented. There should be one more space before it.-->



http://metamodular.com/CLOS-MOP/processing-method-bodies.html
Page 151

<p>Before a method can be created, the list of forms comprising the method body must be converted to a method function. This conversion is a two step process.</p>

<!-- Robert Strandh version incorrectly closed the <p> above. -->



http://metamodular.com/CLOS-MOP/processing-method-bodies.html
Page 152

<!-- Robert Strandh version said "methodfunction" instead of "method function".-->



http://metamodular.com/CLOS-MOP/subprotocols.html
Page 153

<p>This section provides an overview of the Metaobject Protocols. The detailed behavior of each function, generic function and macro in the Metaobject Protocol is presented in <a href="../generic-functions-and-methods/" class="body-link audited">Chapter 6</a><!-- Stray space here in the Robert Strandh version. -->. The remainder of this chapter is intended to emphasize connections among the parts of the Metaobject Protocol, and to provide some examples of the kinds of specializations and extensions the protocols are designed to support.</p>



http://metamodular.com/CLOS-MOP/class-finalization-protocol.html
Page 155

<p>Class <i>finalization</i> is the process of computing the information a class inherits from its superclasses and preparing to actually allocate instances of the class. The class finalization process includes computing the class' class precedence list, the full set of slots accessible in instances of the class and the full set of default initialization arguments for the class. These values are associated with the class metaobject and can be accessed by calling the appropriate reader. In addition, the class finalization process makes decisions about how instances of the class will be implemented.</p>

<!-- Above, Robert Strandh version said "class precedence list of the class" instead of "class's class precedence list" as in the book. I think there's a good case to be made that Robert Strandh's version is superior, here, but I'm in general being more faithful to the book, so for now I'm going with "class' class precedence list" which is the original with one typo correction. -->


<p>To support forward-referenced superclasses, and to account for the fact that not all classes are actually instantiated, class finalization is not done as part of the initialization <span class="page-transition"></span> of the class metaobject. Instead, finalization is done as a separate protocol, invoked by calling the generic function <a href="../generic-functions-and-methods/#finalize-inheritance" class="body-link generic-function audited">finalize-inheritance</a>. The exact point at which <a href="../generic-functions-and-methods/#finalize-inheritance" class="body-link generic-function audited">finalize-inheritance</a> is called depends on the class of the class metaobject; for <a href="../classes/#standard-class" class="body-link class fixme">standard-class</a> it is called sometime after all the <span class="amop-typo" data-original="classes">class'</span> superclasses are defined, but no later than when the first instance of the class is allocated (by <a href="../generic-functions-and-methods/#allocate-instance" class="body-link generic-function audited">allocate-instance</a>).</p>

<!-- Robert Strandh version instead fixes the above typo with "superclasses of the class". -->




http://metamodular.com/CLOS-MOP/instance-structure-protocol.html
Page 157

<p>Given the location of a directly accessible slot, the value of that slot in an instance can be accessed with the appropriate accessor. For <a href="../classes/#standard-class" class="body-link class fixme">standard-class</a>, this accessor is the function <a href="../generic-functions-and-methods/#standard-instance-access" class="body-link function audited">standard-instance-access</a>. For <a href="../classes/#funcallable-standard-class" class="body-link class fixme">funcallable-standard-class</a>, this accessor is the function <a href="../generic-functions-and-methods/#funcallable-standard-instance-access" class="body-link function audited">funcallable-standard-instance-access</a>. In each case, the arguments to the accessor are the instance and the slot location, in that order. See the definition of each accessor in <a href="../generic-functions-and-methods/" class="body-link audited">Chapter 6</a> for additional restrictions on the use of these <span class="amop-typo" data-original="function">functions</span>.</p>

<!-- Above, Robert Strandh version is missing "in Chapter 6", for some reason. (Was it considered superfluous?) -->

<!-- The following paragraph is completely missing from the Robert Strandh version. -->

<p>Portable programs are permitted to affect and rely on the allocation of locations only in the following limited way: By first defining a portable primary method on <a href="../generic-functions-and-methods/#compute-slots" class="body-link generic-function audited">compute-slots</a> which orders the returned value in a predictable way, and then relying on the defined behavior of the specified around-method to assign locations to all directly accessible slots. <span class="page-transition"></span> Portable programs may compile-in calls to low-level accessors which take advantage of the resulting predictable allocation of slot locations.</p>
